#!/bin/bash

# ppa2pup
# convert an Ubuntu PPA repo file, into a Puppy compatible repo file.

# @TODO1 - fix last few fields of package entries (should contain the supported ubuntu distro, not current system)
[ -z "${whoami}" ] && whoami="$(whoami || $(echo user) )"  #One can break the whoami command if the folder premissions are wrong.
                                                           #alternatively we could derive a name from the mode directory as a fallback
[ -z "$TMPDIR" ] && TMPDIR=/tmp/pkg/${whoami} || TMPDIR="${TMPDIR%/}"
TMPDIR=/tmp/pkg/${whoami}
if [ -z "$REPO_DIR" ]; then
  REPO_DIR=${HOME}/.packages       # where the repo files live
  [ -d /var/packages ] && REPO_DIR=/var/packages
fi
. /etc/DISTRO_SPECS

#if [ "$DISTRO_BINARY_COMPAT" != "ubuntu" ] && [ "$DISTRO_BINARY_COMPAT" != "debian" ];then
#  echo "Sorry, you must be running a .deb compatible Puppy Linux"
#  echo "to use this tool. Your Puppy is based on '$DISTRO_BINARY_COMPAT'"
#  exit 1
#fi

#Consider /looking to see if /root/.packages/repo exists. See: https://github.com/s243a/woof-CE/blob/8e44442ca9144b202b73737101231115a87488f1/woof-code/rootfs-packages/PKG/usr/sbin/ppa2pup#L17
[ -z "$REPO_DIR" ] && REPO_DIR="$(realpath /root/.packages)"
[ -z "$REPO_DIR" ]  && REPO_DIR="$(readlink /root/.packages)"
[ -z "$REPO_DIR" ]  && REPO_DIR="/root/.packages)"
[ -z "$PKG_KEEP_EPOCH_IN_DOC_REPO" ] && export PKG_KEEP_EPOCH_IN_DOC_REPO=false
if [ -z "$PKG_KEEP_EPOCH_IN_DOC_REPO" ] || [ "$PKG_KEEP_EPOCH_IN_DOC_REPO" = false ]; then
  AWK_STRIP_EPOCH='\
function stripEpoch(s){
  sub(/^([0-9]*:)?/,"",s)
  return  s
}'
 AWK_STRIP_EPOCH_DEPNDS='stripEpoch(v[2])'
 AWK_STRIP_EPOCH_VERSION='stripEpoch($0)'
else
  AWK_STRIP_EPOCH=''
  AWK_STRIP_EPOCH_DEPNDS='v[2]'
  AWK_STRIP_EPOCH_VERSION='$0'
fi 


if [ ! "$1" ] || [ "$1" = "-h" ] || [ "$1" = "-help" ]
then

  echo "This script creates a Puppy-compatible repo file from a PPA or Debian repo."
  echo
  echo "For Launchpad PPA repos:"
  echo
  echo "  Usage: ppa2pup ppa:<user>/<repo> [debian|ubuntu] [bionic|stretch|artful|etc] [main|all|contrib|non-free|etc]"
  echo
  echo "Examples:"
  echo
  echo "  ppa2pup ppa:team-xbmc/ppa"
  echo
  echo "  ppa2pup ppa:team-xbmc/ppa ubuntu bionic"
  echo
  echo "  ppa2pup ppa:team-xbmc/ppa ubuntu artful"
  echo
  echo "  ppa2pup ppa:team-xbmc/ppa debian stretch"
  echo
  echo
  echo "For other third-party Debian repos:"
  echo
  echo "  Usage: ppa2pup http://site.com/[debian|ubuntu]/ [stretch|bionic|etc] [main|contrib|non-free|etc]"
  echo
  echo "Examples:"
  echo
  echo "  ppa2pup http://rpms.litespeedtech.com/debian/"
  echo
  echo "  ppa2pup http://rpms.litespeedtech.com/debian/ stretch main"
  echo
  echo "  ppa2pup http://repo.steampowered.com/steam/ precise steam"
  echo
  echo "  ppa2pup http://http.kali.org/kali/ kali-bleeding-edge main contrib non-free"
  echo
  echo "NOTE: Any ommitted distro names or versions will be guessed."
  echo
  exit 1

fi


# create a dir to work in
mkdir -p "${TMPDIR}"/ppa_pkgs

# remove any old files
rm "${TMPDIR}"/ppa_pkgs/* 2>/dev/null


# we need to find the correct Packages.gz for the distro (debian/ubuntu),
# distro version (stretch/bionic/etc), and architecture (i386/amd64)

arch='i386'
case $(uname -m) in
  i*86) arch='i386'  ;;
  *64)  arch='amd64' ;;
esac
#This function is used to give an example name
#TODO get input for this function form an external file
function get_sub_distro(){
  local a_repo_url=$1
  local a_distro=$2  
  local a_distro_ver=$3 
  local a_stream=$4
  case "$a_repo_url" in #Not sure how many of these cases are valid. See: https://wiki.debian.org/DebianRepository/Unofficial
  *tor*) echo tor; ;;
  *opera*) echo opera; ;;
  *chrome*) echo chrome; ;;
  *multimedia*) echo multimedia; ;;
  *wrt*) echo wrt; ;;
  *earth*) echo google-earth; ;;
  *talkplugin*) echo google-talk; ;;
  *pagespeed*) echo mod-pagespeed; ;; #This is also google. See: https://wiki.debian.org/DebianRepository/Unofficial
  *mongodb*) echo mongodb; ;;
  *neuro*) echo neuro; ;;
  *opennms*) echo opennms; ;;
  *opera*) echo opera; ;;
  *oss.oracle*) echo oracle-expres; ;;
  *virtualbox*) echo virtualbox; ;;
  *postgresql*) echo postgresql; ;;
  *qgis*) echo qgis; ;;
  *) echo DISTRO_SUB_VERSION; ;;
  esac
}

function get_distro(){
  local a_repo_url=$1
  local a_distro_ver=$2 
  local a_stream=$3
  local maybe_distro_rtn
  distro_rtn=''
  distro_match_weakness='' #'0' Is for the best match. Higher Numbers indicate a weaker match

  distro_rtn=$(cat /root/.pkg/sources-all | awk -v VER="$a_distro_ver" -v  STREAM="$a_stream" -v URL="$a_repo_url" \
  'BEGIN{FS="|"}
     /^.+$/ {
     if ( (index($4,URL) > 0 ) && ( index($3,  "-" VER "-" STREAM) > 0 )  ) {
       split($3, array , "-" )
       print array[2]
       exit 0
     }
    }')
    if [ ! -z "$distro_rtn" ]; then
      distro_match_weakness=0 #Perfect Match
      return 0
    fi
    
        
    case "$a_distro_ver" in
    "${DISTRO_COMPAT_VERSION}"*)
       maybe_distro_rtn="${DISTRO_BINARY_COMPAT}"
       distro_match_weakness=3 #Okay Match        
       ;;
    sid-*|buster*|stretch*|wheezy*|squeeze*|lenny*|etch*|sarge*|woody*|potato*|slink*|hamm*)
       maybe_distro_rtn=debian; 
       distro_match_weakness=4 #Probably Okay Match     
       ;;   
    jessie*)
      maybe_distro_rtn=debian;
      distro_match_weakness=5 #Poor Match -- Might also be devuan so return an error       
      ;;
    ceres*|beowulf*|ascii*)
      maybe_distro_rtn=devuan;
      distro_match_weakness=4 #Probably Okay Match
      ;;        
    eoan*|disco*|bionic*|xenial*|trusty|cosmic*|artful*|zesty*|wily*|utopic*|saucy*|raring*|quantal*|precise*|oneiric*|lucid*|karmic*|jaunty*|intrepid*|hardy*|gusty*|feisty*|edgy*|dapper*|breezy*|hoary*|warty*)
      maybe_distro_rtn=ubuntu
      distro_match_weakness=4 #Probably Okay Match
      ;;           
    *)
      maybe_distro_rtn="${DISTRO_BINARY_COMPAT}"
      distro_match_weakness=8 #Very Poor Match (Default Used)
      ;; #Return an error since the distro returned might be wrong. 
    esac
    if [ $distro_match_weakness -gt 5 ]; then
      distro_rtn=$(cat /root/.pkg/sources-all | awk -v VER="$a_distro_ver"  \
  'BEGIN{FS="|"}
     /^.+$/ {
     if ( index($3,  "-" VER "-") > 0 )  {
       split($3, array , "-" )
       if ( array[2] != "puppy" ){
         out=array[2] #Todo, what if a distro has a "-" in it's name'
         print out
         exit 0
       }
     }
    }')
      distro_match_weakness=6
      return 0
    fi    
    if [ $distro_match_weakness -gt 5 ]; then
  distro_rtn=$(cat /root/.pkg/sources-all | awk -v VER="${a_distro_ver%%-*}"  \
  'BEGIN{FS="|"}
     /^.+$/ {
     if ( index($3,  "-" VER "-") > 0 )  {
       split($3, array , "-" )
       if ( array[2] != "puppy" ){
         out=array[2] #Todo, what if a distro has a "-" in it's name'
         print out
         exit 0
       }
       exit 0
     }
    }')  
      distro_match_weakness=7
      return 0
    fi      
    distro_rtn="$maybe_distro_rtn"
    return 0 #Maybe as an option give a threashold for an acceptable match level
}

if [[ "$1" =~ 'ppa:' ]]
then

  # we got a 'PPA' URL, lets parse it and get the Packages.gz
  ppaname="${1/*\//}"
  username="${1/\/*/}"
  username="${username//ppa:/}"
  ppaname="${ppaname//ppa:/}"

  # get username, but strip special chars
  PPA_NAME="${username//[-_:]/}"

  distro=${2:-$DISTRO_BINARY_COMPAT}
  distro_ver=${3:-$DISTRO_COMPAT_VERSION}
  repo_name="$distro_ver-$PPA_NAME"
  repo_filename="Packages-$distro-$distro_ver-${PPA_NAME}"
  repo_stream=${4:-main}
  repo_stream2=''
  repo_stream3=''
  repo_stream4=''
  [ "$5" != '' ] && repo_stream2=${5}
  [ "$6" != '' ] && repo_stream3=${6}
  [ "$7" != '' ] && repo_stream4=${7}


  URL=http://ppa.launchpad.net/${username}/${ppaname}/${distro}/dists/${distro_ver}/${repo_stream}/binary-${arch}/Packages.gz
  repo_url=http://ppa.launchpad.net/${username}/${ppaname}/${distro}/

elif [[ "$1" =~ 'http://' ]] || [[ "$1" =~ 'https://' ]] || [[ "$1" =~ 'ftp://' ]];then
  repo_type=debian
  # we got a Debian repo source URL, lets parse it and get the Packages.gz

  distro=${DISTRO_BINARY_COMPAT}
  distro_ver=${2:-$DISTRO_COMPAT_VERSION}
  repo_url=$(echo $1 | sed -e 's#/$##g')/
  repo_stream=${3:-main}
  repo_stream2=''
  repo_stream3=''
  repo_stream4=''
  [ "$4" != '' ] && repo_stream2=${4}
  [ "$5" != '' ] && repo_stream3=${5}
  [ "$6" != '' ] && repo_stream4=${6}

  URL=$(echo $1 | sed -e 's#/$##g')/dists/${distro_ver}/${repo_stream}/binary-${arch}/Packages.gz

else

  # didnt get ppa:foo/bar, exit with usage
  $0 -h
  exit 1

fi

function set_PPA_NAME(){
  # if we didn't get the name from the ppa:foo/bar style URL
  local distro_input
  local suggestion1
  local suggestion2
  local PPA_RECORD
  if [[ ! "$1" =~ 'ppa:' ]]
  then

    # check if this repo is already installed (find its name in Pkg sources files)
    if [ -z "$repo_url" ]; then
      PPA_RECORD="$(grep -m1 "^${distro_ver}-${stream:-main}|" /root/.pkg/sources-all | cut -f1,3 -d'|' 2>/dev/null)"
    else
    
      #e.g. "strech-main"
      #Therefore we make sure the repo url also matches to avoid overwring the repo. 
      #Prior to calling this function the trailing slash is stripped off the repo_url. 
      PPA_RECORD="$(grep "^${distro_ver}-${stream:-main}|" /root/.pkg/sources-all | grep -m1 "|${repo_url}/\?|"  | cut -f1,3 -d'|' 2>/dev/null)"

      #e.g. "stretch-tor-main" 
      if [ -z "$PPA_RECORD" ]; then
         PPA_RECORD="$(grep -E "^${distro_ver}-[^-]*-${stream:-main}|" /root/.pkg/sources-all | grep -m1 "|${repo_url}/\?|"  | cut -f1,3 -d'|' 2>/dev/null)"
      fi      

      #e.g. "stretch-main-tor"
      if [ -z "$PPA_RECORD" ]; then
         PPA_RECORD="$(grep "^${distro_ver}-${stream:-main}-" /root/.pkg/sources-all | grep -m1 "|${repo_url}/\?|"  | cut -f1,3 -d'|' 2>/dev/null)"
      fi
      
      #Perhaps a repo doesn't have seperate streams like the puppy repo. 
      if [ -z "$PPA_RECORD" ]; then
         PPA_RECORD="$(grep "^${distro_ver}|" /root/.pkg/sources-all | grep -m1 "|${repo_url}/\?|"  | cut -f1,3 -d'|' 2>/dev/null)"
      fi
            
    fi
    if [ ! -z "$PPA_RECORD" ]; then
      PPA_NAME=$(echo "$PPA_RECORD" | cut -f1 -d"|")
      repo_filename=$(echo "$PPA_RECORD" | cut -f2 -d"|")
    fi
    
    # get repo name and filename
    if [ "$PPA_NAME" = "" ];then
      if [ $(grep -c -m1 "^${distro_ver}-${stream}|" /root/.pkg/sources-all) -gt 0 ]; then
        sub_distro=$(get_sub_distro "${repo_url}" "$distro" "$distro_ver" "$stream")
        suggestion1="${distro_ver}-${sub_distro}-${stream}"
        suggestion2="$suggestion1"
      else
        suggestion1="${distro_ver}-${stream}"
        suggestion2="${distro_ver}-${stream}"
      fi
      while [ 1 -eq 1 ]; do
        
        read -e -p "Enter a repo name, such as '${suggestion1}':  
 "           -i "${suggestion2}" PPA_NAME
        PPA_NAME="$( echo "${PPA_NAME// /-}" | tr '_' '-' | tr '[:upper:]' '[:lower:]' )"
        parse_repoName "$PPA_NAME" #Sets distro, distro_ver and   
        repo_file_guess=${REPO_DIR}/Packages-$distro-${PPA_NAME}
        if [ $(grep -c -m1 "^${PPA_NAME}|" /root/.pkg/sources-all) -gt 0 ]; then
          echo "Error: Repo Name '$distro-$PPA_NAME' already exists in ~/.pkg/sources-all"
          echo "Please choose a new repo name: $distro-$PPA_NAME-MODIFIER"
          suggestion1="$PPA_NAME-MODIFIER"
          suggestion2="$PPA_NAME-"
        elif  [ -f  "$repo_file_guess" ]; then
          
          if [ $(grep -c -m1 "|${repo_file_guess}|" /root/.pkg/sources) -gt 0 ]; then
            echo "Error: Repo file "${repo_file_guess}" already exists in ${$REPO_DIR}/sources-all"
            echo "Please choose a new repo name: $distro-$PPA_NAME-MODIFIER"
            #TODO: the above warning could give a bit more information.          
          else
            echo "${yellow}Warning:${endcolour} Overwriting, previously existing repo file "${repo_file_guess}" found in ${REPO_DIR}/sources-all"
            #TODO: the above warning could give a bit more information. 
            if [ "$ASK" = yes ]; then
                echo "continue [y] or chose a different repo name [n]"
                read -n 1 CONFIRM </dev/tty || CONFIRM=y
                if [ "${CONFIRM:1:1}" != n ] && [ "${CONFIRM:1:1}" != N ]; then
                  repo_filename="Packages-$distro-${PPA_NAME}" 
                  break
                fi
                continue
                 
            fi
            repo_filename="Packages-$distro-${PPA_NAME}" 
            break
          fi
          suggestion1="$PPA_NAME-MODIFIER"
          suggestion2="$PPA_NAME-"
        else
          if [ "$distro_ver" != "$distro_version_parsed" ]; then
            echo -e "${yellow}Warning:${endcolour} distro_ver='${distro_ver}', which differes from the expected distro version (i.e. '${distro_ver_parsed}')"
            if [ "$ASK" = yes ]; then
                echo "continue [y] or chose a different repo name [n]"
                read -n 1 CONFIRM </dev/tty || CONFIRM=y
                if [ "${CONFIRM:1:1}" = n ] || [ "${CONFIRM:1:1}" = N ]; then
                  continue 
                else
                  repo_filename="Packages-$distro-${PPA_NAME}" 
                  break
                fi
            fi
          fi
          # @TODO - give option to fix sources.list if distro_ver != distro_version_parsed
          repo_filename="Packages-$distro-${PPA_NAME}" 
          break
        fi 
      done
      
      if [ -z $URL ]; then
        URL=$(echo $1 | sed -e 's#/$##g')/dists/${distro_ver}/${repo_stream}/binary-${arch}/Packages.gz            
      fi
    else
      PPA_NAME="$( echo "${PPA_NAME// /-}" | tr '_' '-' | tr '[:upper:]' '[:lower:]' )"
    fi
    repo_name="$PPA_NAME" 
  fi
  
}
function parse_distro_version(){
  local distro_name=$1
  local distro_version_last=$2
  local maybe_distro_version=$3
  local version-modifier=${1#*-}
  case "$version-modifier" in
  backports) echo "$maybe_distro_version" ;;
  proposed-updates) echo "$maybe_distro_version" ;;
  updates) echo "$maybe_distro_version" ;;
  backports-sloppy) echo "$maybe_distro_version" ;;
  *) echo "$distro_version_last" ;;
  esac
}
function parse_repoName(){
  Arg1="$(echo $1 | tr "-" " ")"
  set -- $Arg1
  state="parse-Package"
  PPA_NAME="" 
  while [ $# -gt 0 ]; do  
      case "$state" in
      parse-Package)
        if [ "$arg" = "packages" ]  || [ "$arg" = "Packages" ] ; then
          PPA_NAME=$2
          distro_parsed="$2"
          distro_ver_parsed="$3" #For now we'll only use this for error checking. 
          state="parse-Distro_Version"
          shift 3
       else
          PPA_NAME="${1}"
          distro_ver_parsed="$1"
          state="parse-Distro_Version"
          shift 1         
       fi
      ;;
      parse-Distro_Version)
          PPA_NAME="${PPA_NAME}-${1}"
          distro_ver_parsed="$(parse_distro_version  "$distro" "$distro_ver_parsed" "$PPA_NAME")"          
          shift 1; ;;      
      *) #This default action should never happen.
          echo -e "${yellow}Warning:${endcolour} missing parse action in ppa2pup_gawk():parse_repoName()
          PPA_NAME='${PPA_NAME}-${1}'"
          shift 1; ;;
    esac       
  done
  if [ ! -z "$distro_parsed" ]; then
    distro="$distro_parsed"
  fi 
}
PACKAGES_PATH="${TMPDIR}"/ppa_Packages #TODO: use vars instead of litteral paths. See: https://github.com/s243a/woof-CE/blob/8e44442ca9144b202b73737101231115a87488f1/woof-code/rootfs-packages/PKG/usr/sbin/ppa2pup#L204

for stream in $repo_stream $repo_stream2 $repo_stream3 $repo_stream4
do

  [ "$stream" = '' ] && continue

  if [ "$repo_type" = debian ]; then
    #distro="$(get_distro $repo_url $distro_ver $stream)" 
    get_distro $repo_url $distro_ver $stream #Can't run as a subshell if we want to return more than one value
                                             #For instance we might want to return how good our match was. 
    distro="$distro_rtn" #Returned from the above call to get_distro
  fi 

  unset distro_ver_parsed #This var is set for either new repos -- indirectly via set_PPA_NAME() -- or
                          #if the the download failed, in which case we assume the wrong distro version
                          #is given in sources.list and we try to parse the correct version 
                          #(e.g. stretch-backports) from the repo filename. 
  set_PPA_NAME $1
  repo_filename_check="Packages-$distro-${PPA_NAME}"   
  if [ "$repo_filename_check" != "$repo_filename" ]; then
    if [ -z "$repo_filename" ]; then
      echo -e "${yellow}Warning:${endcolour} repo file name missing in config files"
      echo -e "using expected repo file name instead, '$repo_filename_check'"
      repo_filename="$repo_filename_check"
    else
      echo -e "${yellow}Warning:${endcolour} repo filename: '${repo_filename}'"
      echo -e "doesn't match expected repo file name: '${repo_filename_check}'"  
    fi
  fi

  rm "${TMPDIR}"/ppa_Packages "${TMPDIR}"/ppa_Packages.gz 2>/dev/null
  download_failed=false

  download_url=${URL//$repo_stream/$stream}

  wget --quiet $download_url -O "${TMPDIR}"/ppa_Packages.gz 1>/dev/null \
    || download_failed=true
    
  if [ "$download_failed" = true ]; then
    parse_repoName ${PPA_NAME}
    if [ "$distor_ver" != distro_ver_parsed ]; then
      dist_ver_str1=/dists/"$distor_ver"
      dist_ver_str2=/dists/"$distro_ver_parsed"
      download_url=${URL//$dist_ver_str1/$dist_ver_str2}
      unset download_failed
        wget --quiet $download_url -O "${TMPDIR}"/ppa_Packages.gz 1>/dev/null \
    || download_failed=true
      if [ "$download_failed" != true ]; then
         echo -e "${yellow}Warning:${endcolour} expected distro version, \"${distor_ver}\""
         echo -e "but the infered distro version is \"${distro_ver_parsed}\""
         echo -e "Using infered distro version since the expected distro version doesn't exist"
         echo -e "Please check your /etc/apt/sources.list file"
      fi
    fi
  fi

  if [ ! -f "${TMPDIR}"/ppa_Packages.gz ] || [ $download_failed = true ];then
    echo
    echo "ERROR: the PPA repo '$repo_name' not found for $distro $distro_ver:"
    echo
    echo "  $download_url"
    echo
    echo "You could try a different version of the repo."
    echo
    $0 -h
    exit 1
  fi


  gunzip "${TMPDIR}"/ppa_Packages.gz


  # if Packages file is empty, dont create a repo for it
  if [ -z "${TMPDIR}"/ppa_Packages ] || [ ! -s "${TMPDIR}"/ppa_Packages ];then
    continue
  fi


  echo
  echo "Found URL:"
  echo
  echo "  $download_url"
  echo
  echo "Repo to create:"
  echo "   $repo_name"
  echo
  echo "Repo file to create:"
  echo "   ${REPO_DIR}/$repo_filename"
  echo

  rm "${TMPDIR}"/$repo_filename &>/dev/null

  cat "$PACKAGES_PATH" | awk -v PKGOS="$distro" -v PKGOSVER="$distro_ver" \
'function get_inequality(s){
  switch(s){
    case "<":
      return "lt"
      break
    case ">":
      return "gt"
      break
    case "<=":
      return "le"
      break
    case ">=":
      return "ge"
      break
    case "=":
      return "eq"
      break

    }
    return ""
}
function fixdepends(s,   p,a,dep_i,dep_split,pkg_i,ver_i,v,ineq,sout) {
  split(s,a,",")
  for (p in a) {
    match(a[p],/^[ \t]*([^ \t]+)[ \t]*(\((.*)\))?/,dep_split)
    pkg_i = dep_split[1]
    sout = sout ",+" pkg_i
    if ( length(dep_split) > 1 ){
      ver_i=dep_split[3]
      split(ver_i,v," ")
      ineq=get_inequality(v[1])
      if ( length(v) > 1 ){
        sout = sout "&" ineq '"$AWK_STRIP_EPOCH_DEPNDS"'\
      }
      }
  }
  sub(/^,/,"",sout) ; 
  sub(/(,)?$/,"",sout) ; 
  return sout;
}
'"$AWK_STRIP_EPOCH"'\
/^Package:/     { sub(/^Package: /,"");  PKG=$0; }
/^Version:/     { sub(/^Version: /,"");  PKGVER='"$AWK_STRIP_EPOCH_VERSION"'; }\
/^Filename:/    { sub(/^Filename: /,""); PKGPATH=$0; sub(/\/[^\/]*$/,"",PKGPATH); sub(/.*\//,""); PKGFILE=$0; }
/^Priority:/    { sub(/^Priority: /,""); PKGPRIO=$0; }
/^Section:/     { sub(/^Section: /,"");  PKGSECTION=$0; }
/^Installed-Size:/ { sub(/^Installed-Size: /,"");  PKGSIZE=$0; }
/^Depends:/     { sub(/^Depends: /,"");     PKGDEP=fixdepends($0) "," PKGDEP; }
/^Pre-Depends:/ { sub(/^Pre-Depends: /,""); PKGDEP=fixdepends($0) "," PKGDEP; }
/^Description:/ { sub(/^Description: /,""); PKGINFO=substr($0,1,200); }
/^$/            { print PKG "_" PKGVER "|" PKG "|" PKGVER "||" PKGSECTION "|" PKGSIZE "K|" PKGPATH "|" PKGFILE  "|" PKGDEP "|" PKGINFO "|" PKGOS "|" PKGOSVER  "|" ;

                  PKG=""; PKGVER=""; PKGSECTION=""; PKGSIZE=""; PKGFILE=""; PKGPATH=""; PKGDEP=""; PKGINFO=""; PKGPRIO="";    }
' > "${TMPDIR}"/$repo_filename



  rm "${TMPDIR}"/ppa_pkgs/* "${TMPDIR}"/${repo_filename}_sorted 2>/dev/null


  # sort & move the repo file
  sort -u "${TMPDIR}"/$repo_filename > "${TMPDIR}"/${repo_filename}_sorted 2>/dev/null


  if [ ! -f "${TMPDIR}"/${repo_filename}_sorted ];then
    echo "Error: Repo file not created!"
    exit 1
  fi

  mv  "${TMPDIR}"/${repo_filename}_sorted  ${REPO_DIR}/$repo_filename

  echo "Success! File created."
  echo

  fallback_repos="$(pkg repo-list | grep -v $repo_name | tr '\n' ' ')"
  repo_entry="$repo_name|deb|$repo_filename|$repo_url||||$fallback_repos"


  # if already added to ~/.pkg/sources[-all], remove it
  if [ "$(cat ~/.pkg/sources     | grep -m1 "^$repo_name|")" != "" ] || \
     [ "$(cat ~/.pkg/sources-all | grep -m1 "^$repo_name|")" != "" ];then
    cat ~/.pkg/sources | grep -v "^$repo_name|" > "${TMPDIR}"/pkgsources
    cat ~/.pkg/sources-all | grep -v "^$repo_name|" > "${TMPDIR}"/pkgsources-all
    mv "${TMPDIR}"/pkgsources ~/.pkg/sources
    mv "${TMPDIR}"/pkgsources-all ~/.pkg/sources-all
  fi


  # add repo entry to ~/.pkg/sources
  pkg add-source "$repo_entry"
  echo

  # refresh list of available repos
  pkg update-sources
  echo
  echo "Repo info:"
  pkg repo-info $repo_name
  echo


  if [ "$(cat ~/.pkg/sources | grep -m1 "^$repo_name|")" != "" ];then
    echo "Success! Repo added and available to use."
    echo
    echo "To use this repo, simply type the following and hit ENTER:"
    echo "  pkg repo $repo_name"
    echo
  fi

done

exit 0
